/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var u=Object.defineProperty;var i=Object.getOwnPropertyDescriptor;var H=Object.getOwnPropertyNames;var b=Object.prototype.hasOwnProperty;var h=(a,e)=>{for(var t in e)u(a,t,{get:e[t],enumerable:!0})},M=(a,e,t,c)=>{if(e&&typeof e=="object"||typeof e=="function")for(let p of H(e))!b.call(a,p)&&p!==t&&u(a,p,{get:()=>e[p],enumerable:!(c=i(e,p))||c.enumerable});return a};var I=a=>M(u({},"__esModule",{value:!0}),a);var w={};h(w,{HeapType:()=>f,maxHeap:()=>k,minHeap:()=>g});module.exports=I(w);var l=a=>{let e=[],t=()=>e.length,c=r=>{if(t()<=1)return;let n=Math.floor((r-1)/2);switch(a){case 1:{e[n]>e[r]&&([e[n],e[r]]=[e[r],e[n]],c(n));break}case 2:{e[n]<e[r]&&([e[n],e[r]]=[e[r],e[n]],c(n));break}}},p=r=>{let n=t(),o=r,s=2*r+1,m=s+1;switch(a){case 1:{s<n&&e[s]<e[o]&&(o=s),m<n&&e[m]<e[o]&&(o=m);break}case 2:{s<n&&e[s]>e[o]&&(o=s),m<n&&e[m]>e[o]&&(o=m);break}}r!==o&&([e[r],e[o]]=[e[o],e[r]],p(o))};return{add:r=>{e.push(r),c(e.length-1)},poll:()=>{if(t()<=0)return null;let r=e[0];return e[0]=e[t()-1],e.pop(),p(0),r},peek:()=>t()>0?e[0]:null,size:t,isLeaf:r=>{let n=t();return r>=Math.floor(n/2)&&r<n}}};var f=(t=>(t[t.MinHeap=1]="MinHeap",t[t.MaxHeap=2]="MaxHeap",t))(f||{}),k=()=>l(2),g=()=>l(1);0&&(module.exports={HeapType,maxHeap,minHeap});
