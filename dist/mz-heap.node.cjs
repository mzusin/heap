/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var c=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var L=Object.prototype.hasOwnProperty;var C=(n,o)=>{for(var e in o)c(n,e,{get:o[e],enumerable:!0})},E=(n,o,e,a)=>{if(o&&typeof o=="object"||typeof o=="function")for(let u of x(o))!L.call(n,u)&&u!==e&&c(n,u,{get:()=>o[u],enumerable:!(a=w(o,u))||a.enumerable});return n};var z=n=>E(c({},"__esModule",{value:!0}),n);var K={};C(K,{HeapType:()=>b,findKthGreatest:()=>G,maxHeap:()=>I,minHeap:()=>D});module.exports=z(K);var f=(n,o)=>{let e=[],a=()=>e.length,u=()=>e,m=r=>{if(a()<=1)return;let t=Math.floor((r-1)/2);switch(n){case 1:{e[t]>e[r]&&([e[t],e[r]]=[e[r],e[t]],m(t));break}case 2:{e[t]<e[r]&&([e[t],e[r]]=[e[r],e[t]],m(t));break}}},i=r=>{let t=a(),p=r,l=2*r+1,s=l+1;switch(n){case 1:{l<t&&e[l]<e[p]&&(p=l),s<t&&e[s]<e[p]&&(p=s);break}case 2:{l<t&&e[l]>e[p]&&(p=l),s<t&&e[s]>e[p]&&(p=s);break}}r!==p&&([e[r],e[p]]=[e[p],e[r]],i(p))},h=r=>(e.push(r),m(e.length-1),M()),H=r=>{for(let t=0;t<r.length;t++)h(r[t])},k=()=>{if(a()<=0)return null;let r=e[0];return e[0]=e[a()-1],e.pop(),i(0),r},M=()=>a()>0?e[0]:null,g=r=>{let t=a();return r>=Math.floor(t/2)&&r<t};return o&&H(o),{add:h,addList:H,poll:k,peek:M,size:a,isLeaf:g,values:u}};var b=(e=>(e[e.MinHeap=1]="MinHeap",e[e.MaxHeap=2]="MaxHeap",e))(b||{}),I=n=>f(2,n),D=n=>f(1,n),G=(n,o)=>{if(o<0)return null;let e=I(n);for(let a=0;a<o-1&&e.poll()!==null;a++);return e.peek()};0&&(module.exports={HeapType,findKthGreatest,maxHeap,minHeap});
