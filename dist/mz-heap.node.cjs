/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var l=Object.defineProperty;var H=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var h=Object.prototype.hasOwnProperty;var M=(a,e)=>{for(var n in e)l(a,n,{get:e[n],enumerable:!0})},I=(a,e,n,c)=>{if(e&&typeof e=="object"||typeof e=="function")for(let p of b(e))!h.call(a,p)&&p!==n&&l(a,p,{get:()=>e[p],enumerable:!(c=H(e,p))||c.enumerable});return a};var k=a=>I(l({},"__esModule",{value:!0}),a);var w={};M(w,{HeapType:()=>f,maxHeap:()=>g,minHeap:()=>L});module.exports=k(w);var u=a=>{let e=[],n=()=>e.length,c=t=>{if(n()<=1)return;let r=Math.floor((t-1)/2);switch(a){case 1:{e[r]>e[t]&&([e[r],e[t]]=[e[t],e[r]],c(r));break}case 2:{e[r]<e[t]&&([e[r],e[t]]=[e[t],e[r]],c(r));break}}},p=t=>{let r=n(),o=t,s=2*t+1,m=s+1;switch(a){case 1:{s<r&&e[s]<e[o]&&(o=s),m<r&&e[m]<e[o]&&(o=m);break}case 2:{s<r&&e[s]>e[o]&&(o=s),m<r&&e[m]>e[o]&&(o=m);break}}t!==o&&([e[t],e[o]]=[e[o],e[t]],p(o))},i=t=>{e.push(t),c(e.length-1)};return{add:i,addList:t=>{for(let r=0;r<t.length;r++)i(t[r])},poll:()=>{if(n()<=0)return null;let t=e[0];return e[0]=e[n()-1],e.pop(),p(0),t},peek:()=>n()>0?e[0]:null,size:n,isLeaf:t=>{let r=n();return t>=Math.floor(r/2)&&t<r}}};var f=(n=>(n[n.MinHeap=1]="MinHeap",n[n.MaxHeap=2]="MaxHeap",n))(f||{}),g=()=>u(2),L=()=>u(1);0&&(module.exports={HeapType,maxHeap,minHeap});
