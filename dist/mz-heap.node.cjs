/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var f=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var L=Object.prototype.hasOwnProperty;var k=(o,t)=>{for(var p in t)f(o,p,{get:t[p],enumerable:!0})},C=(o,t,p,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let u of x(t))!L.call(o,u)&&u!==p&&f(o,u,{get:()=>t[u],enumerable:!(e=w(t,u))||e.enumerable});return o};var d=o=>C(f({},"__esModule",{value:!0}),o);var O={};k(O,{HeapType:()=>l,maxHeap:()=>z,minHeap:()=>D});module.exports=d(O);var i=(o,t,p)=>{let e=[],u=()=>e.length,c=r=>{if(u()<=1)return;let n=Math.floor((r-1)/2);switch(o){case 1:{e[n]>e[r]&&([e[n],e[r]]=[e[r],e[n]],c(n));break}case 2:{e[n]<e[r]&&([e[n],e[r]]=[e[r],e[n]],c(n));break}}},H=r=>{let n=u(),a=r,m=2*r+1,s=m+1;switch(o){case 1:{m<n&&e[m]<e[a]&&(a=m),s<n&&e[s]<e[a]&&(a=s);break}case 2:{m<n&&e[m]>e[a]&&(a=m),s<n&&e[s]>e[a]&&(a=s);break}}r!==a&&([e[r],e[a]]=[e[a],e[r]],H(a))},h=(r,n)=>{if(e.push(r),c(e.length-1),n!==void 0)switch(o){case 2:{(u()>n||p)&&b();break}case 1:{(u()<n||p)&&b();break}}return I()},M=(r,n)=>{for(let a=0;a<r.length;a++)h(r[a],n||p)},b=()=>{if(u()<=0)return null;let r=e[0];return e[0]=e[u()-1],e.pop(),H(0),r},I=()=>u()>0?e[0]:null,g=r=>{let n=u();return r>=Math.floor(n/2)&&r<n};return t&&M(t,p),{add:h,addList:M,poll:b,peek:I,size:u,isLeaf:g}};var l=(p=>(p[p.MinHeap=1]="MinHeap",p[p.MaxHeap=2]="MaxHeap",p))(l||{}),z=(o,t)=>i(2,o,t),D=(o,t)=>i(1,o,t);0&&(module.exports={HeapType,maxHeap,minHeap});
