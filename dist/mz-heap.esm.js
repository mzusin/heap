/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var c=(o,l)=>{let e=[],r=()=>e.length,p=()=>e,a=n=>{if(r()<=1)return;let t=Math.floor((n-1)/2);switch(o){case 1:{e[t]>e[n]&&([e[t],e[n]]=[e[n],e[t]],a(t));break}case 2:{e[t]<e[n]&&([e[t],e[n]]=[e[n],e[t]],a(t));break}}},f=n=>{let t=r(),u=n,s=2*n+1,m=s+1;switch(o){case 1:{s<t&&e[s]<e[u]&&(u=s),m<t&&e[m]<e[u]&&(u=m);break}case 2:{s<t&&e[s]>e[u]&&(u=s),m<t&&e[m]>e[u]&&(u=m);break}}n!==u&&([e[n],e[u]]=[e[u],e[n]],f(u))},b=n=>(e.push(n),a(e.length-1),h()),i=n=>{for(let t=0;t<n.length;t++)b(n[t])},I=()=>{if(r()<=0)return null;let n=e[0];return e[0]=e[r()-1],e.pop(),f(0),n},h=()=>r()>0?e[0]:null,g=n=>{let t=r();return n>=Math.floor(t/2)&&n<t};return l&&i(l),{add:b,addList:i,poll:I,peek:h,size:r,isLeaf:g,values:p}};var H=(e=>(e[e.MinHeap=1]="MinHeap",e[e.MaxHeap=2]="MaxHeap",e))(H||{}),M=o=>c(2,o),E=o=>c(1,o),L=(o,l)=>{if(l<0)return null;let e=M(o);for(let r=0;r<l-1&&e.poll()!==null;r++);return e.peek()},d=(o,l)=>{if(l<0)return null;let e=E(o);for(let r=0;r<l-1&&e.poll()!==null;r++);return e.peek()},w=(o,l)=>{if(l<0)return[];let e=[],r=M(o);for(let p=0;p<l;p++){let a=r.poll();if(a===null)break;e.push(a)}return e},C=(o,l)=>{if(l<0)return[];let e=[],r=E(o);for(let p=0;p<l;p++){let a=r.poll();if(a===null)break;e.push(a)}return e};export{H as HeapType,L as findKthLargestValue,d as findKthSmallestValue,w as findTopKLargestElements,C as findTopKSmallestElements,M as maxHeap,E as minHeap};
