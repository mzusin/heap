/*
https://github.com/mzusin/heap
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var f=(t,r)=>{let e=[],n=()=>e.length,o=()=>e,m=l=>{if(n()<=1)return;let u=Math.floor((l-1)/2);switch(t){case 1:{e[u]>e[l]&&([e[u],e[l]]=[e[l],e[u]],m(u));break}case 2:{e[u]<e[l]&&([e[u],e[l]]=[e[l],e[u]],m(u));break}}},b=l=>{let u=n(),p=l,s=2*l+1,a=s+1;switch(t){case 1:{s<u&&e[s]<e[p]&&(p=s),a<u&&e[a]<e[p]&&(p=a);break}case 2:{s<u&&e[s]>e[p]&&(p=s),a<u&&e[a]>e[p]&&(p=a);break}}l!==p&&([e[l],e[p]]=[e[p],e[l]],b(p))},h=l=>(e.push(l),m(e.length-1),g()),d=l=>{for(let u=0;u<l.length;u++)h(l[u])},x=()=>{if(n()<=0)return null;let l=e[0];return e[0]=e[n()-1],e.pop(),b(0),l},g=()=>n()>0?e[0]:null,K=l=>{let u=n();return l>=Math.floor(u/2)&&l<u};return r&&d(r),{add:h,addList:d,poll:x,peek:g,size:n,isLeaf:K,values:o}};var H=(e=>(e[e.MinHeap=1]="MinHeap",e[e.MaxHeap=2]="MaxHeap",e))(H||{}),i=t=>f(2,t),c=t=>f(1,t);var z=(t,r)=>{var e;return(e=t.sort((n,o)=>o-n)[r-1])!=null?e:null},S=(t,r)=>{var e;return(e=t.sort((n,o)=>n-o)[r-1])!=null?e:null},T=(t,r)=>{if(r<0||r>=t.length)return null;let e=i(t);for(let n=0;n<r-1&&e.poll()!==null;n++);return e.peek()},V=(t,r)=>{if(r<0||r>=t.length)return null;let e=c(t);for(let n=0;n<r-1&&e.poll()!==null;n++);return e.peek()},w=(t,r)=>{if(r<0||r>=t.length)return null;let e=c();for(let n=0;n<t.length;n++)e.add(t[n]),e.size()>r&&e.poll();return e.peek()},k=(t,r)=>{if(r<0||r>=t.length)return null;let e=i();for(let n=0;n<t.length;n++)e.add(t[n]),e.size()>r&&e.poll();return e.peek()};var D=(t,r)=>{let e=t.slice(0);return e.sort((n,o)=>o-n),e.splice(0,r)},O=(t,r)=>{let e=t.slice(0);return e.sort((n,o)=>n-o),e.splice(0,r)},U=(t,r)=>{if(r<0)return[];let e=[],n=i(t);for(let o=0;o<r;o++){let m=n.poll();if(m===null)break;e.push(m)}return e},j=(t,r)=>{if(r<0)return[];let e=[],n=c(t);for(let o=0;o<r;o++){let m=n.poll();if(m===null)break;e.push(m)}return e},q=(t,r)=>{if(r<0)return[];let e=c();for(let o=0;o<t.length;o++)e.add(t[o]),e.size()>r&&e.poll();let n=[];for(;e.size()>0;){let o=e.poll();if(o===null)break;n.push(o)}return n},A=(t,r)=>{if(r<0)return[];let e=i();for(let o=0;o<t.length;o++)e.add(t[o]),e.size()>r&&e.poll();let n=[];for(;e.size()>0;){let o=e.poll();if(o===null)break;n.push(o)}return n};export{H as HeapType,w as findKthLargestValue,z as findKthLargestValueNaive,T as findKthLargestValueNaive1,k as findKthSmallestValue,S as findKthSmallestValueNaive,V as findKthSmallestValueNaive1,q as findTopKLargestElements,D as findTopKLargestElementsNaive,U as findTopKLargestElementsNaive1,A as findTopKSmallestElements,O as findTopKSmallestElementsNaive,j as findTopKSmallestElementsNaive1,i as maxHeap,c as minHeap};
